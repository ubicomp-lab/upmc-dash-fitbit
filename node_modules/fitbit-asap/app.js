import * as tslib_1 from "tslib";
import { readFileSync, unlinkSync, writeFileSync } from "fs";
import { peerSocket } from "messaging";
var debug = false;
var queue = [];
try {
    queue = readFileSync("_asap_queue", "cbor");
    if (!Array.isArray(queue)) {
        queue = [];
    }
}
catch (error) {
    queue = [];
}
function enqueue(message, options) {
    options = options || {};
    options.timeout = options.timeout || 86400000;
    var data = {
        _asap_id: queue.length > 0 ? Math.max.apply(Math, tslib_1.__spread(queue)) + 1 : 1,
        _asap_created: Date.now(),
        _asap_timeout: options.timeout,
        _asap_message: message,
        _asap_receipt: false
    };
    writeFileSync("_asap_" + data._asap_id, data, "cbor");
    queue.push(data._asap_id);
    writeFileSync("_asap_queue", queue, "cbor");
    if (queue.length === 1) {
        process();
    }
    debug && console.log("Enqueued message #" + data._asap_id);
}
function dequeue(id) {
    if (id) {
        for (var i in queue) {
            if (queue[i] === id) {
                try {
                    unlinkSync("_asap_" + id);
                }
                catch (error) {
                    debug && console.log(error);
                }
                queue.splice(i, 1);
                break;
            }
        }
        debug && console.log("Dequeued message #" + id);
    }
    else {
        for (var i in queue) {
            unlinkSync("_asap_" + queue[i]);
        }
        queue = [];
        debug && console.log("Dequeued all messages");
    }
    writeFileSync("_asap_queue", queue, "cbor");
    process();
}
function process() {
    if (queue.length > 0) {
        var id = queue[0];
        try {
            var message = readFileSync("_asap_" + id, "cbor");
            if (message._asap_created + message._asap_timeout < Date.now()) {
                dequeue(id);
            }
            else {
                try {
                    peerSocket.send(message);
                }
                catch (error) {
                    debug && console.log(error);
                }
            }
        }
        catch (_a) {
            dequeue(id);
        }
    }
}
peerSocket.addEventListener("open", function () {
    debug && console.log("Peer socket opened");
    process();
});
peerSocket.addEventListener("message", function (event) {
    var data = event.data;
    if (data._asap_id > -1) {
        if (data._asap_receipt) {
            dequeue(data._asap_id);
        }
        else {
            asap.onmessage(data._asap_message);
            try {
                peerSocket.send({ _asap_id: data._asap_id, _asap_receipt: true });
            }
            catch (error) {
                debug && console.log(error);
            }
        }
    }
});
var asap = {
    send: enqueue,
    cancel: dequeue,
    onmessage: function () { }
};
export default asap;
//# sourceMappingURL=app.js.map